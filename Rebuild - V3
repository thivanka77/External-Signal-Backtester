//@version=5
strategy("External Signal Backtester", overlay=true, pyramiding=0)
var float entryPrice = na


// === Inputs ===
exitMode     = input.string("Opposite Signal", "Exit Mode", options=["Opposite Signal","Fixed RR"])
slMode       = input.string("ATR", "Stop Loss Mode", options=["ATR","Candle Lookback","Swing High/Low","Structure","Moving Average"])
rrInput      = input.float(2.0,"Risk/Reward",step=0.1)
atrPeriod    = input.int(14,"ATR Period")
atrMult      = input.float(2.0,"ATR Multiplier")
lookbackBars = input.int(5,"Candle Lookback Bars")
swingLen     = input.int(5,"Swing Length (bars)")
swingMargin  = input.float(0.5,"Swing Margin (points)")
pivotLeft    = input.int(2,"Pivot Left Bars")
pivotRight   = input.int(2,"Pivot Right Bars")

// Moving Average Stop inputs
maType   = input.string("SMA", "MA Type", options=["SMA","EMA","WMA","VWMA","ALMA","HMA"])
maLength = input.int(20, "MA Length")


buySrc  = input.source(title="Buy Signal Source", defval=close)
sellSrc = input.source(title="Sell Signal Source", defval=close)

// === Max Trades Limit ===
maxTrades = input.int(2, "Max Trades to Show", minval=1)

// === Signal Mapping ===
startLongTrade  = ta.crossover(buySrc, 0)
startShortTrade = ta.crossover(sellSrc, 0)

// === Variables to hold SL/TP ===
var float stopPrice   = na
var float targetPrice = na

// --- Position Size (fixed at 1) ---
var float longQty  = 1.0
var float shortQty = 1.0
var float longStop  = na
var float shortStop = na

// Function to calculate selected MA
f_ma(src, length, maType) =>
    ma = switch maType
        "SMA"  => ta.sma(src, length)
        "EMA"  => ta.ema(src, length)
        "WMA"  => ta.wma(src, length)
        "VWMA" => ta.vwma(src, length)
        "ALMA" => ta.alma(src, length, 0.85, 6)
        "HMA"  => ta.hma(src, length)
    ma


// Detect recent pivots for structure-based stops
recentLow  = ta.pivotlow(low, pivotLeft, pivotRight)
recentHigh = ta.pivothigh(high, pivotLeft, pivotRight)


if exitMode == "Fixed RR"
    if slMode == "ATR"
        longStop  := close - ta.atr(atrPeriod) * atrMult
        shortStop := close + ta.atr(atrPeriod) * atrMult
    else if slMode == "Candle Lookback"
        longStop  := ta.lowest(low, lookbackBars)
        shortStop := ta.highest(high, lookbackBars)
    else if slMode == "Swing High/Low"
        longStop  := ta.lowest(low, swingLen) - swingMargin
        shortStop := ta.highest(high, swingLen) + swingMargin
    else if slMode == "Structure"
        if not na(recentLow)
            longStop  := recentLow - swingMargin
        if not na(recentHigh)
            shortStop := recentHigh + swingMargin
    else if slMode == "Moving Average"
        maValue = f_ma(close, maLength, maType)
        longStop  := maValue
        shortStop := maValue
    else if slMode == "Moving Average"
        maValue = f_ma(close, maLength, maType)
        longStop  := maValue
        shortStop := maValue


// === Entry & Exit Logic ===
if exitMode == "Opposite Signal"
    if startLongTrade and strategy.position_size == 0
        entryPrice := close
        strategy.entry("Long", strategy.long, qty=longQty)

    if startShortTrade and strategy.position_size == 0
        entryPrice := close
        strategy.entry("Short", strategy.short, qty=shortQty)

    // Opposite signal closes trades
    if sellSrc == 1 and strategy.position_size > 0
        strategy.close("Long")
    if buySrc == 1 and strategy.position_size < 0
        strategy.close("Short")

if exitMode == "Fixed RR"
    if startLongTrade and strategy.position_size == 0
        entryPrice := close
        strategy.entry("Long", strategy.long, qty=longQty)
        stopPrice  := longStop
        targetPrice:= close + (close - stopPrice) * rrInput
        strategy.exit("Long Exit", "Long", stop=stopPrice, limit=targetPrice)

    if startShortTrade and strategy.position_size == 0
        entryPrice := close
        strategy.entry("Short", strategy.short, qty=shortQty)
        stopPrice  := shortStop
        targetPrice:= close - (stopPrice - close) * rrInput
        strategy.exit("Short Exit", "Short", stop=stopPrice, limit=targetPrice)

// ----------- Visual elements -------------- // 
plot(stopPrice, "Stop Loss", color=color.red, style=plot.style_linebr)
plot(targetPrice, "Target", color=color.green, style=plot.style_linebr)

// === Entry & Exit Arrows for last N trades ===
lastIndex = strategy.closedtrades - 1

// Precompute arrays of entry/exit bars for up to maxTrades
var entryBars = array.new_int()
var exitBars  = array.new_int()

array.clear(entryBars)
array.clear(exitBars)

if strategy.closedtrades > 0
    for n = 0 to math.min(lastIndex, maxTrades - 1)
        tradeIndex = lastIndex - n
        entryBar   = strategy.closedtrades.entry_bar_index(tradeIndex)
        exitBar    = strategy.closedtrades.exit_bar_index(tradeIndex)
        array.push(entryBars, entryBar)
        array.push(exitBars, exitBar)

// Plot arrows globally (outside loop)
plotshape(array.includes(entryBars, bar_index), 
          title="Entry Arrow", 
          style=shape.triangleup, 
          location=location.belowbar, 
          color=color.green, 
          size=size.small, 
          text="Entry")

plotshape(array.includes(exitBars, bar_index), 
          title="Exit Arrow", 
          style=shape.triangledown, 
          location=location.abovebar, 
          color=color.red, 
          size=size.small, 
          text="Exit")


// === Stats Table (Wins, Losses, Ratio for last N trades) ===
var table statsTable = na
if na(statsTable)
    statsTable := table.new(position.top_right, 3, 2, border_width=1)

int totalWins   = 0
int totalLosses = 0

if strategy.closedtrades > 0
    lastIndex = strategy.closedtrades - 1
    for n = 0 to math.min(lastIndex, maxTrades - 1)
        tradeIndex = lastIndex - n
        pl = strategy.closedtrades.profit(tradeIndex)
        if pl > 0
            totalWins += 1
        else if pl < 0
            totalLosses += 1

string ratioText = totalLosses > 0 ? str.tostring(totalWins / totalLosses, "#.##") : "N/A"

// Update table every bar
table.cell(statsTable, 0, 0, "Wins",     text_color=color.white, bgcolor=color.black)
table.cell(statsTable, 1, 0, "Losses",   text_color=color.white, bgcolor=color.black)
table.cell(statsTable, 2, 0, "Win/Loss", text_color=color.white, bgcolor=color.black)

table.cell(statsTable, 0, 1, str.tostring(totalWins),   text_color=color.green)
table.cell(statsTable, 1, 1, str.tostring(totalLosses), text_color=color.red)
table.cell(statsTable, 2, 1, ratioText,                 text_color=color.yellow)
